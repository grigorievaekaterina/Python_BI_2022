# -*- coding: utf-8 -*-
"""HW_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h83zgHyzmc6OacKk0k-aB4qEE969xzMD

# Задание 1 (5 баллов)

Напишите классы **Chat**, **Message** и **User**. Они должны соответствовать следующим требованиям:

**Chat**:
+ Должен иметь атрибут `chat_history`, где будут храниться все сообщения (`Message`) в обратном хронологическом порядке (сначала новые, затем старые)
+ Должен иметь метод `show_last_message`, выводящий на экран информацию о последнем сообщении
+ Должен иметь метод `get_history_from_time_period`, который принимает два опциональных аргумента (даты с которой и по какую мы ищем сообщения и выдаём их). Метод также должен возвращать объект типа `Chat`
+ Должен иметь метод `show_chat`, выводящий на экран все сообщения (каждое сообщение в таком же виде как и `show_last_message`, но с разделителем между ними)
+ Должен иметь метод `recieve`, который будет принимать сообщение и добавлять его в чат

**Message**:
+ Должен иметь три обязательных атрибута
    + `text` - текст сообщения
    + `datetime` - дата и время сообщения (встроенный модуль datetime вам в помощь). Важно! Это должна быть не дата создания сообщения, а дата его попадания в чат! 
    + `user` - информация о пользователе, который оставил сообщение (какой тип данных использовать здесь, разберётесь сами)
+ Должен иметь метод `show`, который печатает или возвращает информацию о сообщении с необходимой информацией (дата, время, юзер, текст)
+ Должен иметь метод `send`, который будет отправлять сообщение в чат

**User**:
+ Класс с информацией о юзере, наполнение для этого класса придумайте сами

Напишите несколько примеров использования кода, которое показывает взаимодействие между объектами.

В тексте задания намерено не указано, какие аргументы должны принимать методы, пускай вам в этом поможет здравый смысл)

В этом задании не стоит флексить всякими продвинутыми штуками, для этого есть последующие

В этом задании можно использовать только модуль `datetime`
"""

import datetime

class Chat:
    
    def __init__(self, chat_history=[]):
        self.chat_history = chat_history
    
    def show_last_message(self):
        print(*self.chat_history[0])
    
    def get_history_from_time_period(self, date_from=None, date_to=None):
        if date_from and date_to:
            message_from = -1
            message_to = 0
            for message_ind in range(len(self.chat_history)-1, -1, -1):
                if message_from == -1 and self.chat_history[message_ind][1] == date_from:
                    message_from = message_ind
                if self.chat_history[message_ind][1] == date_to:
                    message_to = message_ind
            return self.chat_history[message_to:message_from+1]
        else:
            return self.chat_history
    
    def show_chat(self):
        for message in self.chat_history:
            print(*message)
    
    def recieve(self, Message):
        message = [Message.text, datetime.datetime.now().strftime("%d/%m/%y %H:%M"), Message.user.info()]
        self.chat_history.insert(0, message)

class Message:
    
    def __init__(self, text:str, user, chat):
        self.text = text
        self.datetime = None
        self.user = user
        self.chat = chat
            
    def show(self):
        for message in self.chat.chat_history:
            if message[0] == self.text:
                print(*message)
                return
        else:
            print(*[self.text, "DRAFT", self.user.info()])
    
    def send(self):
        self.chat.recieve(self)

class User:
    
    def __init__(self, name:str, nickname=None, age=None, city=None):
        self.name = name
        self.nickname = nickname
        self.age = age
        self.city = city
    
    def info(self):
        if self.nickname and self.name.find(self.nickname) == -1:
            self.name += " " + self.nickname
        if self.age and self.name.find(self.age) == -1:
            self.name += " " + self.age
        if self.city and self.name.find(self.city) == -1:
            self.name += " " + self.city
        return self.name

user1 = User("Kate", "heycallisto", "22", "Dolgoprudny")
user2 = User("Sergei", "OlegDoom", "22", "Dolgoprudny")

chat = Chat()

Message("Hi, Serge! How are you? :)", user1, chat).send()
Message("Hi, Kate) Fine, and you?", user2, chat).send()

Message("Same) What about going to the gym tomorrow?", user1, chat).send()
Message("Nice idea, wanted to offer the same, but you was faster!", user2, chat).send()

Message("Ha-ha! See you later :)", user1, chat).send()
Message("See you! Have a nice day)", user2, chat).send()

chat.show_chat()

Message("Thank you, you too!", user1, chat).show()

Message("Ha-ha! See you later :)", user1, chat).show()

chat.show_last_message()

"""# Задание 2 (3 балла)

В питоне как-то слишком типично и неинтересно происходят вызовы функций. Напишите класс `Args`, который будет хранить в себе аргументы, а функции можно будет вызывать при помощи следующего синтаксиса.

Использовать любые модули **нельзя**, да и вряд-ли это как-то поможет)
"""

sum([1, 2])

class Args:
    
    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs
    
    def __rlshift__(self, func):
        return func(*self.args, **self.kwargs)

sum << Args([1, 2])

(lambda a, b, c: a**2 + b + c) << Args(1, 2, c=50)

"""# Задание 3 (5 баллов)

Сделайте класс наследник `float`. Он должен вести себя как `float`, но также должен обладать некоторыми особенностями:
+ При получении атрибутов формата `<действие>_<число>` мы получаем результат такого действия над нашим числом
+ Создавать данные атрибуты в явном виде, очевидно, не стоит

Подсказка: если в процессе гуглёжки, вы выйдете на такую тему как **"Дескрипторы", то это НЕ то, что вам сейчас нужно**

Примеры использования ниже
"""

class StrangeFloat(float):
    
    def __getattr__(self, action:str):
        if "_" in action and action[0:2] != "__":
            splitted = action.split("_")
            action = splitted[0][0:3]
            number = float(splitted[1])
            if action == "div":
                action = "__truediv__"
            elif action == "flo":
                action = "__floordiv__"
            else:
                action = "__" + action + "__"
            return StrangeFloat(getattr(self, action)(number))

"""*PS 
Такой метод как выше будет работать только для тех методов которые сокращаются как subtract -> sub и для целочисл/обычного деления, тк прописано.*
"""

number = StrangeFloat(3.5)

number.add_1

number.subtract_20

number.multiply_5

number.divide_25

number.add_1.add_2.multiply_6.divide_8.subtract_9

getattr(number, "add_-2.5")   # Используем getattr, так как не можем написать number.add_-2.5 - это SyntaxError

number + 8   # Стандартные для float операции работают также

number.as_integer_ratio()   # Стандартные для float операции работают также  (это встроенный метод float, писать его НЕ НАДО)

(3.5).as_integer_ratio()   # Проверка

number.floordivide_25   # Добавила целочисленное деление

3.5 // 25

"""# Задание 4 (3 балла)

В данном задании мы немного отдохнём и повеселимся. От вас требуется заменить в данном коде максимально возможное количество синтаксических конструкций на вызовы dunder методов, dunder атрибутов и dunder переменных.

Маленькая заметка: полностью всё заменить невозможно. Например, `function()` можно записать как `function.__call__()`, но при этом мы всё ещё не избавляемся от скобочек, так что можно делать так до бесконечности `function.__call__.__call__.__call__.__call__.....__call__()` и при всём при этом мы ещё не избавляемся от `.` для доступа к атрибутам. В общем, замените всё, что получится, не закапываясь в повторы, как в приведённом примере. Чем больше разных методов вы найдёте и используете, тем лучше и тем выше будет балл

Код по итогу дожен работать и печатать число **4420.0**, как в примере. Структуру кода менять нельзя, просто изменяем конструкции на синонимичные

И ещё маленькая подсказка. Заменить здесь можно всё кроме:
+ Конструкции `for ... in ...`:
+ Синтаксиса создания лямбда функции
+ Оператора присваивания `=`
+ Конструкции `if-else`
"""

import numpy as np


matrix = []
for idx in range(0, 100, 10):
    matrix += [list(range(idx, idx + 10))]
    
selected_columns_indices = list(filter(lambda x: x in range(1, 5, 2), range(len(matrix))))
selected_columns = map(lambda x: [x[col] for col in selected_columns_indices], matrix)

arr = np.array(list(selected_columns))

mask = arr[:, 1] % 3 == 0
new_arr = arr[mask]

product = new_arr @ new_arr.T

if (product[0] < 1000).all() and (product[2] > 1000).any():
    print(product.mean())

np = __import__('numpy')

matrix = list.__call__()

for idx in range(0, 100, 10):
    matrix.__iadd__([list(range(idx, idx.__add__(10)))])

selected_columns_indices = list(filter(lambda x: x in range(1, 5, 2), range(matrix.__len__())))
selected_columns = map(lambda x: [x.__getitem__(col) for col in selected_columns_indices], matrix)

arr = np.array(list(selected_columns))

mask = arr.__getitem__((slice(None), 1)).__mod__(3).__eq__(0)

new_arr = arr.__getitem__(mask)

product = new_arr.__matmul__(new_arr.T)

if product.__getitem__(0).__lt__(1000).__eq__(True).__and__(product.__getitem__(2).__gt__(1000)).__contains__(True):
    print(product.mean().__str__())

"""# Задание 5 (10 баллов)

Напишите абстрактный класс `BiologicalSequence`, который задаёт следующий интерфейс:
+ Работа с функцией `len`
+ Возможность получать элементы по индексу и делать срезы последовательности (аналогично строкам)
+ Вывод на печать в удобном виде и возможность конвертации в строку
+ Возможность проверить алфавит последовательности на корректность

Напишите класс `NucleicAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Данный класс имеет новый метод `complement`, возвращающий комплементарную последовательность
+ Данный класс имеет новый метод `gc_content`, возвращающий GC-состав (без разницы, в процентах или в долях)

Напишите классы наследники `NucleicAcidSequence`: `DNASequence` и `RNASequence`
+ `DNASequence` должен иметь метод `transcribe`, возвращающий транскрибированную РНК-последовательность
+ Данные классы не должны иметь <ins>публичных методов</ins> `complement` и метода для проверки алфавита, так как они уже должны быть реализованы в `NucleicAcidSequence`.

Напишите класс `AminoAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Добавьте этому классу один любой метод, подходящий по смыслу к аминокислотной последовательности. Например, метод для нахождения изоэлектрической точки, молекулярного веса и т.д.

Комментарий по поводу метода `NucleicAcidSequence.complement`, так как я хочу, чтобы вы сделали его опредедённым образом:

При вызове `dna.complement()` или условного `dna.check_alphabet()` должны будут вызываться соответствующие методы из `NucleicAcidSequence`. При этом, данный метод должен обладать свойством полиморфизма, иначе говоря, внутри `complement` не надо делать условия а-ля `if seuqence_type == "DNA": return self.complement_dna()`, это крайне не гибко. Данный метод должен опираться на какой-то общий интерфейс между ДНК и РНК. Создание экземпляров `NucleicAcidSequence` не подразумевается, поэтому код `NucleicAcidSequence("ATGC").complement()` не обязан работать, а в идеале должен кидать исключение `NotImplementedError` при вызове от экземпляра `NucleicAcidSequence`

Вся сложность задания в том, чтобы правильно организовать код. Если у вас есть повторяющийся код в сестринских классах или родительском и дочернем, значит вы что-то делаете не так.


Маленькое замечание: По-хорошему, между классом `BiologicalSequence` и классами `NucleicAcidSequence` и `AminoAcidSequence`, ещё должен быть класс-прослойка, частично реализующий интерфейс `BiologicalSequence`, но его писать не обязательно, так как задание и так довольно большое (правда из-за этого у вас неминуемо возникнет повторяющийся код в классах `NucleicAcidSequence` и `AminoAcidSequence`)
"""

from abc import ABC, abstractmethod

class BiologicalSequence(ABC):    
    @abstractmethod
    def __len__(self):
        pass
    
    @abstractmethod
    def __getitem__(self, ind):
        pass

    @abstractmethod
    def __repr__(self):
        pass
    
    @abstractmethod
    def __str__(self):
        pass
    
    @abstractmethod
    def check_alphabet(self):
        pass

class NucleicAcidSequence(BiologicalSequence):

    dna_complement = {"A": "T", "a": "t",
                      "T": "A", "t": "a",
                      "G": "C", "g": "c",
                      "C": "G", "c": "g"}

    rna_complement = {"A": "U", "a": "u",
                      "U": "A", "u": "a",
                      "G": "C", "g": "c",
                      "C": "G", "c": "g"}

    def __init__(self, seq:str):
        self.seq = seq
    
    def __len__(self):
        return len(self.seq)

    def __getitem__(self, ind):
        return self.seq.__getitem__(ind)
    
    def __repr__(self):
        return repr(self.seq)
    
    def __str__(self):
        return str(self.seq)
    
    def check_alphabet(self, dna_complement = dna_complement, rna_complement = rna_complement):
        acid = 0
        for i in self.seq:
            if i in dna_complement and i not in rna_complement:
                continue
            elif i not in dna_complement and i in rna_complement:
                acid = 1
            elif i in dna_complement and i in rna_complement:
                continue
            else:
                raise SyntaxError("Wrong alphabet. Please rewrite sequence")
        if acid != 0:
            return "RNA"
        else:
            return "DNA" 
    
    
    def complement(self, dna_complement = dna_complement, rna_complement = rna_complement):
        compl_seq = []
        if self.check_alphabet() == "DNA":
            for i in self.seq:
                compl_seq.append(dna_complement[i])
        elif self.check_alphabet() == "RNA":
            for i in self.seq:
                compl_seq.append(rna_complement[i])
        else:
            raise SyntaxError("Wrong alphabet. Please rewrite sequence")
        return ''.join(compl_seq)
    
    def gc_content(self):
        GC = "GCgc"
        counter = 0
        if self.check_alphabet() == "DNA" or self.check_alphabet() == "RNA":
            for i in self.seq:
                if i in GC:
                    counter += 1
            gc_percentage = counter/len(self.seq) * 100
            return gc_percentage
        else:
            raise SyntaxError("Wrong alphabet. Please rewrite sequence")

class DNASequence(NucleicAcidSequence):

    dna_transcribe = {"A": "A", "a": "a",
                      "T": "U", "t": "u",
                      "G": "G", "g": "g",
                      "C": "C", "c": "c"}
    
    def __init__(self, seq:str):
        self.seq = seq
    

    def transcribe(self, dna_transcribe = dna_transcribe):
        if self.check_alphabet() == "DNA":
            trans_seq = []
            for i in self.seq:
                trans_seq.append(dna_transcribe[i])
            return ''.join(trans_seq)
        else:
            raise SyntaxError("Wrong alphabet. Please rewrite sequence")

class RNASequence(NucleicAcidSequence):

    def __init__(self, seq:str):
        self.seq = seq

class AminoAcidSequence(BiologicalSequence):

    protein = {'A': 71.04, 'C': 103.01, 'D': 115.03, 
               'E': 129.04, 'F': 147.07, 'G': 57.02, 
               'H': 137.06, 'I': 113.08, 'K': 128.09,
               'L': 113.08, 'M': 131.04, 'N': 114.04,
               'P': 97.05, 'Q': 128.06, 'R': 156.10,
               'S': 87.03, 'T': 101.05, 'V': 99.07, 
               'W': 186.08, 'Y': 163.06}

    def __init__(self, seq:str):
        self.seq = seq
    
    def __len__(self):
        return len(self.seq)

    def __getitem__(self, ind):
        return self.seq.__getitem__(ind)
    
    def __repr__(self):
        return repr(self.seq)
    
    def __str__(self):
        return str(self.seq)
    
    def check_alphabet(self, protein = protein):
        for i in self.seq:
            if i not in protein:
                raise SyntaxError("Wrong alphabet. Please rewrite sequence")
        return True
    
    def protein_weight(self, protein = protein):
        if self.check_alphabet():
            weight = 0
            for i in self.seq:
                weight += protein[i]
            return weight
        else:
            raise SyntaxError("Wrong alphabet. Please rewrite sequence")

"""Проверка на работоспособность"""

RNASequence("AUGGUAGUA").complement()

RNASequence("AUFGUAGUA").complement()

DNASequence("AUFGUAGUA").complement()

DNASequence("ATCG").complement()

DNASequence("ATCG").transcribe()

AminoAcidSequence("ACDEF").protein_weight()

AminoAcidSequence("ACDEFB").protein_weight()

DNASequence("ATCG").gc_content()

RNASequence("AUCG").gc_content()